# 语法分析

## 语法分析简介

语法分析是编译程序的核心规则，按照源语言的语法规则进行分析，输出分析树并进行语法分析阶段的错误处理。

- 从源程序记号序列中识别出各类的语法成分
- 进行语法检查

鉴于分析树的树状数据结构，我们有两种分析方法：

- 自顶向下的分析方法
- 自底向上的分析方法

### 语法错误的处理

错误处理的目标是：

- 报告错误的位置和性质
- 迅速从错误中恢复
- 不应该明显影响对于正确程序的分析速度

错误处理有如下的策略：

- 紧急恢复：一旦发现错误，分析程序每次抛弃一个输入记号，直到扫描到的记号属于某个指定的同步记号集合。

  同步记号集合往往是定界符，如语句结束符（分号），语句起始符，块结束符（END）。

- 短语级恢复

- 出错产生式

- 全局纠正

## 自顶向下的分析防范

### 递归下降分析

从文法的开发符号出发，进行推导，试图推导出要分析的输入串的过程。对于给定的输入符号串，从对应于文法开始符号的根节点出来，建立分析树。整个过程是一个试探的过程，反复使用不同的产生式谋求匹配输入符号串的过程。

**例**：按照如下的文法分析`abbcde`
$$
\rm{S \to aAcBe} \\
\rm{A \to b | Ab} \\
\rm{B \to d}
$$
首先尝试$\rm{S \to aAcBe}$，对于$A$分别尝试两种生成情况递归生成中间两个$\rm{b}$，依次类推递归尝试所有的生成式。

使用递归下降分析可以得到一个**最左推导序列**。

> 关于**推导**的补充知识：
>
> 现在有
> $$
> \rm{\alpha A\beta => \alpha \gamma \beta}
> $$
> 其中$=>$ 表示**一步推导**，其中称左边直接推导出右边，也可以说右边是左边的直接推导，或者右边直接归约到左边。

> 关于**短语**的补充知识：
>
> 假定$\rm{\alpha \beta \delta}$ 是文法的一个句型，如果存在：
> $$
> S \Rightarrow^{*} \alpha A \delta \\
> A \Rightarrow^{+} \beta
> $$
> 就称$\beta$ 是句型$\rm{\alpha \beta \delta}$关于非终结符号$A$的短语。
>
> 如果存在：
> $$
> S \Rightarrow^{*} \alpha A \delta \\
> A \Rightarrow \beta
> $$
> 那么就称$\beta$ 是句型$\rm{\alpha \beta \delta}$关于非终结符号$A$的直接短语。
>
> 一个句型的最左直接短语称为该局性的句柄。

因此对于输入串的扫描是自左至右进行的，只有使用最左推导，才能保证按照扫描的顺序匹配输入串。

但是递归下降分析方法存在缺陷：

- 左递归的文法，可能导致分析过程陷入死循环
- 回溯
- 工作的重复
- 效率低

### 递归调用预测分析

一个确定的，不带回溯的递归下降分析方法。

1. 如何克服回溯？

   根据所面临的输入符号准确的指派一个候选式去执行任务。

2. 那么如何准确指派，首先对文法存在要求。

   - 不含有左递归
   - $FIRST(\alpha_i) \cap FIRST(\alpha_j) = \empty$ 其中$i \neq j$

   > 解释一下$FIRST$的规定：
   > $$
   > FIRST(\alpha) = \{a | \alpha \Rightarrow a \beta\}
   > $$
   > 也就是非终结符$\alpha$能够推出的一个终结符。

#### 预测分析程序的构造

1. 构造预测分析程序转换图

   每个非终结符号都有一张图，边的标记可以使终结符号和非终结符号。

   对于非终结符号$A$的转移表示对$A$的过程调用。

   对于终结符号$a$的转移，表示下一个输入符号应该是$a$

   为了从文法构造一个转换图，我们需要首先对文法进行改写：

   - 重写文法
   - 消除左递归
   - 提取左公因子

   > 消除左递归：
   >
   > 
   >
   > 首先考虑简单情况。如果存在产生式：
   > $$
   > \rm{A \to A \alpha | \beta}
   > $$
   > 可以改写为：
   > $$
   > A \to \beta A' \\
   > A' \to \alpha A' | \epsilon
   > $$
   > ![image-20230926113422832](./grammar-analyzer/image-20230926113422832.png)

   >提取左公因子：
   >
   >如果存在产生式：
   >$$
   >\rm{A \to \alpha \beta_1 | \alpha \beta_2}
   >$$
   >那么提取左公因子$\alpha$，有：
   >$$
   >A \to \alpha A' \\
   >A' \to \beta_1 | \beta_2
   >$$

   然后对于每个非终结符号$A$：创建一个初始状态和一个终结状态，对于每一个产生式$A \to X_1 X_2 \cdots X_n$创建一条从初态到终态的路径。

2. 转换图的工作过程

   从文法开始符号所对应的转换图的开始状态开始分析。

   经过若干动作之后，处于状态$S$，指针指向符号$a$:

   ![image-20230926114657078](./grammar-analyzer/image-20230926114657078.png)

3. 转换图的化简

   反复代入化简。

   ![image-20230926114931452](./grammar-analyzer/image-20230926114931452.png)

4. 预测分析程序的实现

   ![image-20230926115738715](./grammar-analyzer/image-20230926115738715.png)

   ```c
   void procE()
   {
       procT();
       if (input == '+')
       {
           pointer.forward();
           procE();
       }
   }
   ```

### 非递归预测分析

使用一张分析表和一个栈联合控制，输入对输入符号的自顶向下分析。

预测分析程序的模型如图所示：

![image-20231010101812965](./grammar-analyzer/image-20231010101812965.png)

- 输入缓冲区：存储被分析的输入符号串
- 符号栈：存放文法符号
- 分析表：存储产生式，根据给定的栈顶和当前指针定位产生式
- 输出流

> 说明，`$`表示起始和终结符号

#### 预测分析控制程序

根据栈顶符号`X`和当前输入符号`a`，分析动作存在四种可能：

1. `X`和`a`都是终结符号，停止分析
2. `X=a`但是不为终结符号，弹栈并向前移动输入指针
3. `X`在分析表中但是`a`不是，调用错误处理程序报告错误并进行错误恢复
4. 访问分析表获得产生式，先弹栈，并将生成式的右部符号串按反序压入栈中

可以写出伪代码：

![image-20231010102924356](./grammar-analyzer/image-20231010102924356.png)

#### 预测分析表的构造

1. 首先进行文法的改写，同递归调用分析预测的要求和步骤一致。

2. `FIRST`集合及其构造

   `FIRST`集合的定义为：

   对于任何文法符号串$\alpha$，$FIRST(\alpha)$是$\alpha$可以推导出的开头终结符号集合。
   $$
   FIRST(\alpha) = \{a | \alpha \Rightarrow^* a \cdots \}
   $$
   特别需要注意的是，如果`\alpha`可以推出空串，那么$\epsilon \in FIRST(\alpha)$。

   构造`FIRST`集合：

   - 如果$X \in V_T$, 那么$ FIRST(X) = \{x\}$
   - 如果$X \in V_N$， 那么针对所有$X$的生成式$X \to  a\cdots$，将$a$加入
   - 如果$X \to \epsilon$ ,加入空串
   - 如果存在$X \to Y \cdots$ ，加入$FIRST(Y)$中所有非空的元素

   重复该过程，知道所有的集合不再变化为止。

3. `FOLLOW`集合及其构造

   `FOLLOW`集合的定义为：

   假定$S$为文法的开始符号，对于文法中的任何非终结符，集合$FOLLOW(A)$式在所有句型中紧跟$A$之后出现的终结符号或者$\$$组成的集合。
   $$
   FOLLOW(A) = \{a | S \Rightarrow^* \cdots Aa \cdots\}
   $$
   特别的，如果$S \Rightarrow ^* \cdots A$，那么规定$\$ \in FOLLOW(A)$，注意集合中不能存在空串。

   构造`FOLLOW`集合：

   - 对于文法开始符号$S$，将$\$$放入$FOLLOW(S)$中
   - 如果存在产生式$A \to \alpha B \beta$，那么将$FIRST(\beta)$中的所有非空元素加入$FOLLOW(B)$中
   - 如果$A \to \alpha B$，或者$A \to \alpha B \beta$且存在$\beta \Rightarrow^* \epsilon$，那么将$FOLLOW(A)$中的所有元素加入到$FOLLOW(B)$中

   重复此过程，直到所有集合不再变化为止。

4. 预测分析表的构造

   ![image-20231010111718252](./grammar-analyzer/image-20231010111718252.png)

**LL(1文法**：如果一个文法的预测分析表不含有多重定义的表项，则称该文法为LL(1)文法。

LL(1)文法的判定方法：

当且仅当对于该文法的每一个产生式$A \to \alpha | \beta$ ，都有：

- $FIRST(\alpha) \cap FIRST(\beta) = \empty$
- 如果$\beta \to \epsilon$, 那么 $FIRST(\alpha) \cap FOLLOW(A) = \empty$

或者根据分析表来判断。
