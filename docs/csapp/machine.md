# 程序的机器级表示

也就是汇编语言。不过根据`CSAPP`，我们并不需要完全掌握汇编语言，只需要学会阅读汇编语言，并通过对汇编语言的理解写出执行效率更高的`C`语言代码，毕竟在产生汇编语言这件事上，编译器比我们做得更好也更有耐心。

## Intel处理器和架构的历史

### Intel x86 处理器

在桌面，笔记本和服务器市场都占据很大的市场份额。这主要是因为Intel长期坚持的向前兼容策略，现在生产的处理器仍然可以兼容到1978年出现的8086处理器。

这类的处理器都是复杂指令计算机`CISC`，这类架构的特点就是提供极为复杂繁多的硬件指令供开发者使用，但是其中只有很小的一个子集是被`Linux`操作系统所使用的。

### Intel 64位处理器历史

2001年，Intel首次推出64位的计算机处理器，但是这款处理器几乎不兼容32位的应用程序，运行的效率极低，在推出之后的不久就被市场所拒绝。同时，AMD公司采用逐步演进的方式推进64位架构的普及，同时完全兼容之前的32为，在市场中获得了极大的成功，因此现在的64位架构也被称为`amd64`。

`IA32`就是Intel公司的32位指令集，`x86-64`就是64位的指令集了。

## 汇编语言基础

### 定义

- 架构`Architecture`：也被称为`ISA`，为了编写汇编语言我们需要知道的处理器知识。比如具体的指令集和寄存器。
- 微架构`Microarchitecture`：架构的具体实现。比如缓存的大小和处理器运行的频率。
- 代码格式：
  - 机器码：字节级别的程序代码，处理器可以直接执行
  - 汇编代码：机器码的文本表示方式。
- ISAs举例：
  - Intel: IA32, x86-64
  - Arm
  - RSIC V

### 汇编语言代码的运行环境

![架构图](./images/arth.png)

在汇编语言运行时，处理器的下列信息是可以访问的：

- `PC`: Program counter 程序计数器，也就是下一条需要执行的指令的地址
- 寄存器文件：程序中大量使用的变量存储在这里
- 条件码：存储各种操作的结果类型，比如运算中是否溢出，是否为0

汇编语言支持多种不同的数据类型，在实际运行的过程中，针对不同的数据类型有着不同的指令，这些指令往往只有后缀上的区别。下面是支持的数据类型：

- 1，2，3，8字节的整数
- 4，8，10字节的浮点数
- 8，16，32，64字节或者更多的向量数据，由`SIMD`指令集使用，通过被用在媒体数据中
- 字节编码的指令
- 在运行中没有任何聚合的数据类型，例如结构体或者联合

在汇编语言运行的过程中还可以访问一系列的寄存器文件，有一些寄存器的具有着约定的含义，例如`%rsp`寄存器就储存着栈指针的地址。同时使用寄存器还得遵循一系列的规则。每个寄存器都是8个字节大小，但是我们可以通过一些其他的名称来访问这些寄存器的低字节空间。

条件码在执行条件跳转指令，类似于C语言中的`if`时，有着很大的作用。不过我们通常不需要访问这些数据，而是通过一系列的指令来实现条件跳转操作。

### 汇编语言指令

汇编语言中的可执行的操作：在内存和寄存器之前传送数据，对寄存器或者内存中存储的数据进行算术操作，在执行指令的过程中进行控制转移。

#### 传送数据指令

```assembly
movq Source, Dest
```

指令的操作数：

- 立即数：直接编写在代码中的整数，不可变。例如`$0x400$`
- 寄存器：十六个可以访问的寄存器中的一个
- 内存：在内存中通过地址访问的一系列的连续的字符，这个地址一般通过一个寄存器指定。这串字符的长度通过指令操作的类型来确定，例如指令的后缀是`q`，就说明这是一个8字节的操作指令，这串字符的长度就是8个字节。指令操作的数据类型不仅在访问内存时有用，在访问寄存器时也有用，我们已经知道使用寄存器也可以访问寄存器低位的空间了。

| 数据类型     | 汇编代码后缀 | 大小 |
| ------------ | ------------ | ---- |
| 字节         | b            | 1    |
| 字           | w            | 2    |
| 双字         | l            | 4    |
| 四字         | q            | 8    |
| 单精度浮点数 | s            | 4    |
| 双精度浮点数 | l            | 8    |

> 双精度浮点数和双字的后缀一样不会引起指令的歧义，操作整数和浮点数采用的两套不同的指令

传送指令举例：

`movq $0x4 %ras`：将立即数4复制到寄存器`ras`。

在汇编语言中，我们有以下的几种方式来访问内存：

- `(R)`其中`R`是一个特定的寄存器，这句指令就是访问寄存器`R`存储地址的内存空间。例如：`movq $-0x134 (%rax)`：将一个立即数复制到内存中，目标内存地址由寄存器`%rax`指定。
- `D(R)`其中`D`是一个立即数，`R`就是寄存器。这句指令就是在上一句指令的基础上添加了一个常数的偏移量`D`，所访问的内存地址就是`R`储存的值加上`D`，例如`movq $0x123 0x8(%rsp)`，将一个立即数复制到寄存器`%rsp`存储值加上8对应的内存空间中
- `D(Rb,Ri,S)`，最为通用的内存访问方式。其中`D`是一个立即数，称作“偏移量”，`Rb,Ri`是两个寄存器，`s`也是一个立即数，称作“比例因子”，这个语句访问地址的计算公式是$Rb+ Ri \times S + D$所对应的值

> 其实访问内存的方式有且仅有一种，就是最通用的那种访问方式，前两种方式就是第三种方式的简化形式。同时需要说明的，简化的方式并不只有上述的两种。

#### 地址计算指令

`leaq Src, Dest`：`Src`是一个地址表达式，`Dest`存放前述的表达式计算的值。地址表达式的格式和上面内存中寻址的方式是一致的。

在实际中，地址计算指令并不全部是用于地址计算的。因为人们发现这个指令在进行一些运算是十分的方便，例如：为了计算`x+4 * y`，其中`x`储存在`%rdi`寄存器中，`y`存储在`%rsi`寄存器中，我们可以用这条指令来计算这个表达式的值`leaq (%rdi, %rsi, 4), %rdi`，并且把结果存储在`%rdi`寄存器中。

#### 算术运算指令

![算数运算指令](./images/arithmetic.png)

下面给出一段C语言程序编译为汇编代码的例子，辅助理解。首先，C语言代码如下：

```C
long arith(long x, long y, long z)
{
    long t1 = x+y;long t2 = z+t1;
    long t3 = x+4;long t4 = y * 48;
    long t5 = t3 + t4;long rval= t2 * t5;
    return rval;
}
```

这个函数编译为汇编代码是：

```nasm
arith:
	leaq (%rdi,%rsi), %rax# t1
	addq %rdx, %rax# t2
	leaq (%rsi,%rsi,2), %rdx
	salq $4, %rdx# t4
	leaq 4(%rdi,%rdx), %rcx# t5
	imulq %rcx, %rax# rval
	ret
```

同时，在这段汇编代码中，寄存器和C语言中变量的对应关系为：

| 寄存器 | C语言中的变量      |
| ------ | ------------------ |
| `%rdi` | `x`                |
| `%rsi` | `y`                |
| `%rdx` | `z`, `t4`          |
| `%rax` | `t1`, `t2`,` rval` |
| `%rcx` | `t5`               |

~~结合着下面给出的寄存器使用列表，这段汇编代码还是很好理解的。~~我们可以看见在汇编代码中，编译器使用的大量的`leaq`来实现算术运算。