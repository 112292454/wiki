# 数据的位级表示

## 数据的表示

### Bits

- Bits的取值可以为0或者1
- 计算机可以通过Bits判断做什么，Bits还可以代表计算机中的数据
- 在电路中，Bits是通过电压的高低来代表的

### 字节的编码

1 Byte = 8 bits

- 二进制 00000000~11111111
- 十进制0~255
- 十六进制 00~FF

> 在数据的前面加上0x即表示十六进制

### 其他数据类型

在32位和64位构架的计算机上，数据类型的表达可能不一样。

## 位级运算

### 布尔代数

- And 和
- Or 或
- Not 非
- Exclusive Or 异或

可以直接将布尔代数的运算方法运用在bit向量上，也就是一个比特串上的运算。所有布尔代数中的运算特性都可以运用在比特向量上。

> 布尔代数和集合运算上的相似性：
>
> - 与——集合的交集
> - 或——集合的并集
> - 非——集合的补集
> - 异或——对称差（Symmetric difference）

### C语言中的位级运算

&，|，~，^运算符都可以在C语言中使用。

#### 同C语言中逻辑操作的比较

C语言中还提供了一系列的逻辑运算符：&&, ||, !，应注意逻辑运算符和位级运算符之间的区别。

在逻辑运算中，具有以下的特征：

- 将0视为假
- 任何不为0的数据都是真
- 总是返回0或者1
- 在逻辑表达式中，如果前半段的语句即可判断整个语句的真假，则直接返回而不继续执行（Early termination）

### 移位运算

#### 左移

将比特向量向左移位，多余的位直接丢弃，空余的位采用0填充。

#### 右移

将比特向量向右移位，如果是逻辑右移，就在向量的左边填上0，如果是算术移位，就在向量的左边填上符号位，也就是填上最高位。

> 如果移动一个负值或者移动的长度超过了比特向量的长度（字长），那么就是未定义的操作，在不同机器中会表现出不同的行为。

## 整数

### 有符号整数和无符号整数的表示

将一个比特串转换为无符号的整数：
$$
B2U(X) = \sum_{i=0}^{w-1}x_i \times 2^i
$$
将一个比特串转换为有符号的整数：
$$
B2T(X) =- x_{w-1} \times 2^{w-1} + \sum_{i=0}^{w-2}x_i \times 2^i
$$

### 表示范围

对于一个无符号的整数，其最小值是$U_{min} = 0$， 其的最大值是$U_{max} = 2^w - 1$。

对于一个有符号的整数，其最小值是$T_{min} = -2^{w-1}$，其的最大值是$T_{max}=2^{w-1}-1$。

对于一个短整型类型的整数，其的字长是16位：

|           | 16     |
| --------- | ------ |
| $U_{max}$ | 65535  |
| $T_{max}$ | 32767  |
| $U_min$   | -32768 |

我们不难发现，其中存在着：

- $|T_{min}| = T_{max} + 1$
- $U_{max} = 2 \times T_{max} + 1$

- 无符号整数和有符号整数中非负数的位级表示是一致的
- 每一个比特串都只代表着一个唯一的整数，即唯一性，也就是我们可以建立起一对函数将整数转换为比特串

### 类型转换和强制类型转换

在有符号和无符号整数相互转换的过程中，先转换为一个比特串，再重新表示，也就是说再转换的过程中，位级的表示是不会变换的。

在C语言中：

- 在默认情况下，常量均是作为有符号的整数看待的
- 在有符号数和无符号数之间的强制类型转化将按照位级表示不变的方式执行
- 在赋值的过程中发生的隐式类型转换也按照位级表示不变的方式执行
- 在一个有符号和无符号混杂的表达式中，有符号的整数会被先转换为无符号的整数

| 常数         | 常数2           | 结果 | 运算时的类型 |
| ------------ | --------------- | ---- | ------------ |
| 0            | 0U              | ==   | unsigned     |
| -1           | 0               | <    | signed       |
| -1           | 0U              | >    | unsigned     |
| 214748647    | -214748647-1    | >    | signed       |
| 214748647U   | -214748647-1    | <    | unsigned     |
| -1           | -2              | >    | signed       |
| (unsigned)-1 | -2              | >    | unsigned     |
| 214748647    | 214748648U      | <    | unsigned     |
| 214748647    | (int)214748648U | >    | signed       |

总结：类型转换都是保持位级表示不变而重新解释。

### 扩展和截断

将低字长的整数转换为高字长的整数称为扩展，无符号数在前面填0，而有符号数在前面填1。

将高字长的整数转换为低字长的整数称为截断，直接抛弃前面的位就可以了，再对结果进行重新解释。