# 数据的位级表示

## 数据的表示

### Bits

- Bits的取值可以为0或者1
- 计算机可以通过Bits判断做什么，Bits还可以代表计算机中的数据
- 在电路中，Bits是通过电压的高低来代表的

### 字节的编码

1 Byte = 8 bits

- 二进制 00000000~11111111
- 十进制0~255
- 十六进制 00~FF

> 在数据的前面加上0x即表示十六进制

### 其他数据类型

在32位和64位构架的计算机上，数据类型的表达可能不一样。

## 位级运算

### 布尔代数

- And 和
- Or 或
- Not 非
- Exclusive Or 异或

可以直接将布尔代数的运算方法运用在bit向量上，也就是一个比特串上的运算。所有布尔代数中的运算特性都可以运用在比特向量上。

> 布尔代数和集合运算上的相似性：
>
> - 与——集合的交集
> - 或——集合的并集
> - 非——集合的补集
> - 异或——对称差（Symmetric difference）

### C语言中的位级运算

&，|，~，^运算符都可以在C语言中使用。

#### 同C语言中逻辑操作的比较

C语言中还提供了一系列的逻辑运算符：&&, ||, !，应注意逻辑运算符和位级运算符之间的区别。

在逻辑运算中，具有以下的特征：

- 将0视为假
- 任何不为0的数据都是真
- 总是返回0或者1
- 在逻辑表达式中，如果前半段的语句即可判断整个语句的真假，则直接返回而不继续执行（Early termination）

### 移位运算

#### 左移

将比特向量向左移位，多余的位直接丢弃，空余的位采用0填充。

#### 右移

将比特向量向右移位，如果是逻辑右移，就在向量的左边填上0，如果是算术移位，就在向量的左边填上符号位，也就是填上最高位。

> 如果移动一个负值或者移动的长度超过了比特向量的长度（字长），那么就是未定义的操作，在不同机器中会表现出不同的行为。

## 整数

### 有符号整数和无符号整数的表示

将一个比特串转换为无符号的整数：
$$
B2U(X) = \sum_{i=0}^{w-1}x_i \times 2^i
$$
将一个比特串转换为有符号的整数：
$$
B2T(X) =- x_{w-1} \times 2^{w-1} + \sum_{i=0}^{w-2}x_i \times 2^i
$$

### 表示范围

对于一个无符号的整数，其最小值是$U_{min} = 0$， 其的最大值是$U_{max} = 2^w - 1$。

对于一个有符号的整数，其最小值是$T_{min} = -2^{w-1}$，其的最大值是$T_{max}=2^{w-1}-1$。

对于一个短整型类型的整数，其的字长是16位：

|           | 16     |
| --------- | ------ |
| $U_{max}$ | 65535  |
| $T_{max}$ | 32767  |
| $U_min$   | -32768 |

我们不难发现，其中存在着：

- $|T_{min}| = T_{max} + 1$
- $U_{max} = 2 \times T_{max} + 1$

- 无符号整数和有符号整数中非负数的位级表示是一致的
- 每一个比特串都只代表着一个唯一的整数，即唯一性，也就是我们可以建立起一对函数将整数转换为比特串

### 类型转换和强制类型转换

在有符号和无符号整数相互转换的过程中，先转换为一个比特串，再重新表示，也就是说再转换的过程中，位级的表示是不会变换的。

在C语言中：

- 在默认情况下，常量均是作为有符号的整数看待的
- 在有符号数和无符号数之间的强制类型转化将按照位级表示不变的方式执行
- 在赋值的过程中发生的隐式类型转换也按照位级表示不变的方式执行
- 在一个有符号和无符号混杂的表达式中，有符号的整数会被先转换为无符号的整数

| 常数         | 常数2           | 结果 | 运算时的类型 |
| ------------ | --------------- | ---- | ------------ |
| 0            | 0U              | ==   | unsigned     |
| -1           | 0               | <    | signed       |
| -1           | 0U              | >    | unsigned     |
| 214748647    | -214748647-1    | >    | signed       |
| 214748647U   | -214748647-1    | <    | unsigned     |
| -1           | -2              | >    | signed       |
| (unsigned)-1 | -2              | >    | unsigned     |
| 214748647    | 214748648U      | <    | unsigned     |
| 214748647    | (int)214748648U | >    | signed       |

总结：类型转换都是保持位级表示不变而重新解释。

### 扩展和截断

将低字长的整数转换为高字长的整数称为扩展，无符号数在前面填0，而有符号数在前面填1。

将高字长的整数转换为低字长的整数称为截断，直接抛弃前面的位就可以了，再对结果进行重新解释。

### 加减乘除

#### 无符号整数的相加

按位相加，将溢出的数位直接忽略。或者用更加数学化的语言：
$$
s = UAdd_w(u,v)=(u+v)mod2^w
$$

#### 有符号整数的相加

与无符号整数的加法在位级表现上是一致的，仍然是按位相加，并且忽略溢出的部分。也就是说，运行下面给一段C代码：

```c
int s, t, u, v;
s = (int) ((unsigned)u + (unsigned)v);
t = u + v;
```

在运行之后的结果是`s == t`。

在有符号整数相加的溢出中，如果结果大于等于$2^{w-1}$，那么发生负溢出，结果是一个负数，如果结果小于$-2^{w-1}$，那么发生正溢出，结果是一个负数。

#### 整数的乘法

存储w位的整数的乘法需要$2^w$位的空间。在实际的计算过程中，仍然是忽略掉所有溢出的数位，在数学上就是：
$$
UMult_w(u,v)=(u \times v)mod2^w
$$
有符号数和无符号上乘法在细节上可能存在一定的差异，但是最后计算结果的低位是一致的。

在实现乘以2的幂时，我们可以通过移位操作来实现，也就是说`u << k`得出的结果就是$u \times 2^k$，这个结论对于无符号整数和有符号整数都是成立的。而且对于现代的处理器来说，移位和加法操作远快于乘法操作，因此在计算乘法时，编译器会尽量优化为移位和加法操作来完成。

在无符号整数除以2的幂时，我们可以采用逻辑右移来实现，也就是说`x >> k`就是$\lfloor u / 2^k \rfloor$。在有符号整数除以2的幂时，我们可以采用算术右移来实现，也即`x >> k`就是$\lfloor u / 2^k \rfloor$，但是当结果是负数时，我们希望计算机能向靠近0的方向舍入，也就是向上舍入。于是我们可以进行修正：$(x + 2^k - 1) / 2^k$，通过加上一个整数来使结果”看上去“像是向上取整的。

#### 求负数

对整数求负数，可以通过`-x = ~x + 1`来实现。但是这个运算存在两个特例，`0`和$T_{min}$，这两个数求负数的结果都是它自己。

## 位在内存，指针和字符串

### 面向字节的内存组织

程序通过**地址**来访问内存，我们可以将内存视为一个超级大的字节数组。同时，对于每一个不同的进程，操作系统都提供了一个独立的内存空间供程序使用。

任何计算机都有一个指定的**字长**，通常这个数值指定了`int`类型和地址的字节长度。

### 字节顺序

在内存中储存数据时，显然不可能所有的数据都只占据一个字长的空间。当数据占用了多个字长的空间时，字节的顺序就显得尤为重要。

字节的顺序存在着下面两种情况：

- 大端法
- 小端法

需要指出的是，大端法和小端法并没有任何性能或者其他方面的差异，仅是计算机设计者在设计时的偏好。

> 就像是从大头打破鸡蛋还是从小头打破鸡蛋，这是《格列佛游记》中的一个故事，大端法和小端法的英文名称也是来自于这个典故。

我们可以编写一个C函数来打印一个数据的每个字节：

```C
typedef unsigned char* pointer;
void show_bytes(pointer start, size_tlen)
{
    size_t i;
    for (i= 0; i< len; i++)
        printf(”%p\t0x%.2x\n",start+i, start[i]);
    printf("\n");
}

```

### 字符串的表示

在C语言中，字符串的表示都是一个字符的数组，每个字符都通过`ASCII`的方式进行编码。通过每一个字符串都需要是空终止的，也就是说最后一个字符是0。